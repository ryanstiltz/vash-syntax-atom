"use strict";
var utils = require("../utils/utils");
var nameRegex = /^\s*function\s*(\S*)\s*\(/;
/* istanbul ignore next */
var hasNativeName = typeof (function f() { }).name !== "undefined";
function classNameFromInstance(instance) {
    return functionName(instance.constructor);
}
exports.classNameFromInstance = classNameFromInstance;
/* istanbul ignore next too many hacks for IE here*/
function functionName(func) {
    if (hasNativeName) {
        return func.name;
    }
    else if (func.rdtFuncNameCache666) {
        // super 'special' property name on INSTANCE to avoid hurting those who use browsers that
        // do not support name property even more (IE...)
        return func.rdtFuncNameCache666;
    }
    else {
        var name_1 = func.toString().match(nameRegex)[1];
        func.rdtFuncNameCache666 = name_1;
        return name_1;
    }
}
exports.functionName = functionName;
/**
 * simple Hashtable between a string and some generic value
 * this should be removed once typescript supports ES6 style Hashtable
 */
var HashTable = (function () {
    function HashTable() {
        this._state = {};
    }
    HashTable.prototype.keys = function () {
        return utils.keys(this._state);
    };
    HashTable.prototype.values = function () {
        return utils.values(this._state);
    };
    HashTable.prototype.put = function (key, value) {
        this._state[key] = value;
    };
    HashTable.prototype.putAll = function (other) {
        this._state = utils.assign(this._state, other._state);
    };
    HashTable.prototype.get = function (key) {
        // To avoid edge case with a key called "hasOwnProperty" we need to perform the commented out check below
        // -> if (Object.prototype.hasOwnProperty.call(this._state, key)) { ... } <-
        // however this costs nearly 25% of the parser's runtime.
        // if someone decides to name their Parser class "hasOwnProperty" they deserve what they will get :)
        return this._state[key];
    };
    HashTable.prototype.containsKey = function (key) {
        return utils.has(this._state, key);
    };
    HashTable.prototype.clear = function () {
        this._state = {};
    };
    return HashTable;
}());
exports.HashTable = HashTable;
